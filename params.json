{"name":"Userspace-RCU","tagline":"liburcu is a LGPLv2.1 userspace RCU (read-copy-update) library. This data synchronization library provides read-side access which scales linearly with the number of cores. ","body":"Userspace RCU Implementation\r\n============================\r\n\r\nby Mathieu Desnoyers and Paul E. McKenney\r\n\r\n\r\nBuilding\r\n--------\r\n\r\n    ./bootstrap # skip if using tarball\r\n    ./configure\r\n    make\r\n    make install\r\n    ldconfig\r\n\r\nHints:\r\n\r\n  - Forcing 32-bit build:\r\n\r\n        CFLAGS=\"-m32 -g -O2\" ./configure\r\n\r\n  - Forcing 64-bit build:\r\n\r\n        CFLAGS=\"-m64 -g -O2\" ./configure\r\n\r\n  - Forcing a 32-bit build with 386 backward compatibility:\r\n\r\n        CFLAGS=\"-m32 -g -O2\" ./configure --host=i386-pc-linux-gnu\r\n\r\n  - Forcing a 32-bit build for Sparcv9 (typical for Sparc v9)\r\n\r\n        CFLAGS=\"-m32 -Wa,-Av9a -g -O2\" ./configure\r\n\r\n\r\nArchitectures supported\r\n-----------------------\r\n\r\nCurrently, the following architectures are supported:\r\n\r\n  - Linux x86 (i386, i486, i586, i686)\r\n  - x86 64-bit\r\n  - PowerPC 32/64\r\n  - S390, S390x\r\n  - ARM 32/64\r\n  - MIPS\r\n  - Alpha\r\n  - ia64\r\n  - Sparcv9 32/64\r\n  - Tilera\r\n  - hppa/PA-RISC\r\n\r\nTested on Linux, FreeBSD 8.2/8.3/9.0/9.1/10.0 i386/amd64, and Cygwin.\r\nShould also work on:\r\n\r\n  - Android\r\n  - NetBSD 5\r\n  - OpenBSD\r\n  - Darwin\r\n\r\n(more testing needed before claiming support for these OS).\r\n\r\nLinux ARM depends on running a Linux kernel 2.6.15 or better, GCC 4.4 or\r\nbetter.\r\n\r\nThe GCC compiler versions 3.3, 3.4, 4.0, 4.1, 4.2, 4.3, 4.4 and 4.5 are\r\nsupported, with the following exceptions:\r\n\r\n  - GCC 3.3 and 3.4 have a bug that prevents them from generating volatile\r\n    accesses to offsets in a TLS structure on 32-bit x86. These versions are\r\n    therefore not compatible with `liburcu` on x86 32-bit\r\n    (i386, i486, i586, i686).\r\n    The problem has been reported to the GCC community:\r\n    http://www.mail-archive.com/gcc-bugs@gcc.gnu.org/msg281255.html\r\n  - GCC 3.3 cannot match the \"xchg\" instruction on 32-bit x86 build.\r\n    See http://kerneltrap.org/node/7507\r\n  - Alpha, ia64 and ARM architectures depend on GCC 4.x with atomic builtins\r\n    support. For ARM this was introduced with GCC 4.4:\r\n    http://gcc.gnu.org/gcc-4.4/changes.html.\r\n\r\nClang version 3.0 (based on LLVM 3.0) is supported.\r\n\r\nBuilding on MacOS X (Darwin) requires a work-around for processor\r\ndetection:\r\n\r\n  - 32-bit:\r\n\r\n        ./configure --build=i686-apple-darwin11\r\n\r\n  - 64-bit:\r\n\r\n        ./configure --build=x86_64-apple-darwin11\r\n\r\nFor developers using the Git tree:\r\n\r\nThis source tree is based on the autotools suite from GNU to simplify\r\nportability. Here are some things you should have on your system in order to\r\ncompile the git repository tree :\r\n\r\n  - GNU autotools (automake >=1.10, autoconf >=2.50, autoheader >=2.50)\r\n    (make sure your system wide `automake` points to a recent version!)\r\n  - GNU Libtool >=2.2\r\n    (for more information, go to http://www.gnu.org/software/autoconf/)\r\n\r\nIf you get the tree from the repository, you will need to use the `bootstrap`\r\nscript in the root of the tree. It calls all the GNU tools needed to prepare\r\nthe tree configuration.\r\n\r\nTest scripts provided in the `tests/` directory of the source tree depend\r\non `bash` and the `seq` program.\r\n\r\n\r\nAPI\r\n---\r\n\r\nSee the relevant API documentation files in `doc/`. The APIs provided by\r\nUserspace RCU are, by prefix:\r\n\r\n  - `rcu_`: Read-Copy Update (see [`doc/rcu-api.md`](doc/rcu-api.md))\r\n  - `cmm_`: Concurrent Memory Model\r\n  - `caa_`: Concurrent Architecture Abstraction\r\n  - `cds_`: Concurrent Data Structures\r\n    (see [`doc/cds-api.md`](doc/cds-api.md))\r\n  - `uatomic_`: Userspace Atomic\r\n    (see [`doc/uatomic-api.md`](doc/uatomic-api.md))\r\n\r\n\r\nQuick start guide\r\n-----------------\r\n\r\n### Usage of all urcu libraries:\r\n\r\n  - Define `_LGPL_SOURCE` (only) if your code is LGPL or GPL compatible\r\n    before including the `urcu.h` or `urcu-qsbr.h` header. If your application\r\n    is distributed under another license, function calls will be generated\r\n    instead of inlines, so your application can link with the library.\r\n  - Linking with one of the libraries below is always necessary even for\r\n    LGPL and GPL applications.\r\n  - Define `URCU_INLINE_SMALL_FUNCTIONS` before including Userspace RCU\r\n    headers if you want Userspace RCU to inline small functions (10\r\n    lines or less) into the application. It can be used by applications\r\n    distributed under any kind of license, and does *not* make the\r\n    application a derived work of Userspace RCU.\r\n\r\nThose small inlined functions are guaranteed to match the library\r\ncontent as long as the library major version is unchanged.\r\nTherefore, the application *must* be compiled with headers matching\r\nthe library major version number. Applications using\r\n`URCU_INLINE_SMALL_FUNCTIONS` may be unable to use debugging\r\nfeatures of Userspace RCU without being recompiled.\r\n\r\n\r\n### Usage of `liburcu`\r\n\r\n  1. `#include <urcu.h>`\r\n  2. Link the application with `-lurcu`\r\n\r\nThis is the preferred version of the library, in terms of\r\ngrace-period detection speed, read-side speed and flexibility.\r\nDynamically detects kernel support for `sys_membarrier()`. Falls back\r\non `urcu-mb` scheme if support is not present, which has slower\r\nread-side.\r\n\r\n\r\n### Usage of `liburcu-qsbr`\r\n\r\n  1. `#include <urcu-qsbr.h>`\r\n  2. Link with `-lurcu-qsbr`\r\n\r\nThe QSBR flavor of RCU needs to have each reader thread executing\r\n`rcu_quiescent_state()` periodically to progress. `rcu_thread_online()`\r\nand `rcu_thread_offline()` can be used to mark long periods for which\r\nthe threads are not active. It provides the fastest read-side at the\r\nexpense of more intrusiveness in the application code.\r\n\r\n\r\n### Usage of `liburcu-mb`\r\n\r\n  1. `#include <urcu.h>`\r\n  2. Compile any `_LGPL_SOURCE` code using this library with `-DRCU_MB`\r\n  3. Link with `-lurcu-mb`\r\n\r\nThis version of the urcu library uses memory barriers on the writer\r\nand reader sides. This results in faster grace-period detection, but\r\nresults in slower reads.\r\n\r\n\r\n### Usage of `liburcu-signal`\r\n\r\n  1. `#include <urcu.h>`\r\n  2. Compile any `_LGPL_SOURCE` code using this library with `-DRCU_SIGNAL`\r\n  3. Link the application with `-lurcu-signal`\r\n\r\nVersion of the library that requires a signal, typically `SIGUSR1`. Can\r\nbe overridden with `-DSIGRCU` by modifying `Makefile.build.inc`.\r\n\r\n\r\n### Usage of `liburcu-bp`\r\n\r\n  1. `#include <urcu-bp.h>`\r\n  2. Link with `-lurcu-bp`\r\n\r\nThe BP library flavor stands for \"bulletproof\". It is specifically\r\ndesigned to help tracing library to hook on applications without\r\nrequiring to modify these applications. `rcu_init()`,\r\n`rcu_register_thread()` and `rcu_unregister_thread()` all become nops.\r\nThe state is dealt with by the library internally at the expense of\r\nread-side and write-side performance.\r\n\r\n\r\n### Initialization\r\n\r\nEach thread that has reader critical sections (that uses\r\n`rcu_read_lock()`/`rcu_read_unlock()` must first register to the URCU\r\nlibrary. This is done by calling `rcu_register_thread()`. Unregistration\r\nmust be performed before exiting the thread by using\r\n`rcu_unregister_thread()`.\r\n\r\n\r\n### Reading\r\n\r\nReader critical sections must be protected by locating them between\r\ncalls to `rcu_read_lock()` and `rcu_read_unlock()`. Inside that lock,\r\n`rcu_dereference()` may be called to read an RCU protected pointer.\r\n\r\n\r\n### Writing\r\n\r\n`rcu_assign_pointer()` and `rcu_xchg_pointer()` may be called anywhere.\r\nAfter, `synchronize_rcu()` must be called. When it returns, the old\r\nvalues are not in usage anymore.\r\n\r\n\r\n### Usage of `liburcu-defer`\r\n\r\n  - Follow instructions for either `liburcu`, `liburcu-qsbr`,\r\n    `liburcu-mb`, `liburcu-signal`, or `liburcu-bp` above.\r\n    The `liburcu-defer` functionality is pulled into each of\r\n    those library modules.\r\n  - Provides `defer_rcu()` primitive to enqueue delayed callbacks. Queued\r\n    callbacks are executed in batch periodically after a grace period.\r\n    Do _not_ use `defer_rcu()` within a read-side critical section, because\r\n    it may call `synchronize_rcu()` if the thread queue is full.\r\n    This can lead to deadlock or worse.\r\n  - Requires that `rcu_defer_barrier()` must be called in library destructor\r\n    if a library queues callbacks and is expected to be unloaded with\r\n    `dlclose()`.\r\n\r\nIts API is currently experimental. It may change in future library releases.\r\n\r\n\r\n### Usage of `urcu-call-rcu`\r\n\r\n  - Follow instructions for either `liburcu`, `liburcu-qsbr`,\r\n    `liburcu-mb`, `liburcu-signal`, or `liburcu-bp` above.\r\n    The `urcu-call-rcu` functionality is pulled into each of\r\n    those library modules.\r\n  - Provides the `call_rcu()` primitive to enqueue delayed callbacks\r\n    in a manner similar to `defer_rcu()`, but without ever delaying\r\n    for a grace period.  On the other hand, `call_rcu()`'s best-case\r\n    overhead is not quite as good as that of `defer_rcu()`.\r\n  - Provides `call_rcu()` to allow asynchronous handling of RCU\r\n    grace periods.  A number of additional functions are provided\r\n    to manage the helper threads used by `call_rcu()`, but reasonable\r\n    defaults are used if these additional functions are not invoked.\r\n    See [`doc/rcu-api.md`](doc/rcu-api.md) in userspace-rcu documentation\r\n    for more details.\r\n\r\n\r\n### Being careful with signals\r\n\r\nThe `liburcu` library uses signals internally. The signal handler is\r\nregistered with the `SA_RESTART` flag. However, these signals may cause\r\nsome non-restartable system calls to fail with `errno = EINTR`. Care\r\nshould be taken to restart system calls manually if they fail with this\r\nerror. A list of non-restartable system calls may be found in\r\n`signal(7)`. The `liburcu-mb` and `liburcu-qsbr` versions of the Userspace RCU\r\nlibrary do not require any signal.\r\n\r\nRead-side critical sections are allowed in a signal handler,\r\nexcept those setup with `sigaltstack(2)`, with `liburcu` and\r\n`liburcu-mb`. Be careful, however, to disable these signals\r\nbetween thread creation and calls to `rcu_register_thread()`, because a\r\nsignal handler nesting on an unregistered thread would not be\r\nallowed to call `rcu_read_lock()`.\r\n\r\nRead-side critical sections are _not_ allowed in a signal handler with\r\n`liburcu-qsbr`, unless signals are disabled explicitly around each\r\n`rcu_quiescent_state()` calls, when threads are put offline and around\r\ncalls to `synchronize_rcu()`. Even then, we do not recommend it.\r\n\r\n\r\n### Interaction with mutexes\r\n\r\nOne must be careful to do not cause deadlocks due to interaction of\r\n`synchronize_rcu()` and RCU read-side with mutexes. If `synchronize_rcu()`\r\nis called with a mutex held, this mutex (or any mutex which has this\r\nmutex in its dependency chain) should not be acquired from within a RCU\r\nread-side critical section.\r\n\r\nThis is especially important to understand in the context of the\r\nQSBR flavor: a registered reader thread being \"online\" by\r\ndefault should be considered as within a RCU read-side critical\r\nsection unless explicitly put \"offline\". Therefore, if\r\n`synchronize_rcu()` is called with a mutex held, this mutex, as\r\nwell as any mutex which has this mutex in its dependency chain\r\nshould only be taken when the RCU reader thread is \"offline\"\r\n(this can be performed by calling `rcu_thread_offline()`).\r\n\r\n\r\n### Interaction with `fork()`\r\n\r\nSpecial care must be taken for applications performing `fork()` without\r\nany following `exec()`. This is caused by the fact that Linux only clones\r\nthe thread calling `fork()`, and thus never replicates any of the other\r\nparent thread into the child process. Most `liburcu` implementations\r\nrequire that all registrations (as reader, `defer_rcu` and `call_rcu`\r\nthreads) should be released before a `fork()` is performed, except for the\r\nrather common scenario where `fork()` is immediately followed by `exec()` in\r\nthe child process. The only implementation not subject to that rule is\r\n`liburcu-bp`, which is designed to handle `fork()` by calling\r\n`rcu_bp_before_fork`, `rcu_bp_after_fork_parent` and\r\n`rcu_bp_after_fork_child`.\r\n\r\nApplications that use `call_rcu()` and that `fork()` without\r\ndoing an immediate `exec()` must take special action.  The parent\r\nmust invoke `call_rcu_before_fork()` before the `fork()` and\r\n`call_rcu_after_fork_parent()` after the `fork()`. The child\r\nprocess must invoke `call_rcu_after_fork_child()`.\r\nEven though these three APIs are suitable for passing to\r\n`pthread_atfork()`, use of `pthread_atfork()` is **STRONGLY\r\nDISCOURAGED** for programs calling the glibc memory allocator\r\n(`malloc()`, `calloc()`, `free()`, ...) within `call_rcu` callbacks.\r\nThis is due to limitations in the way glibc memory allocator\r\nhandles calls to the memory allocator from concurrent threads\r\nwhile the `pthread_atfork()` handlers are executing.\r\n\r\nCombining e.g.:\r\n\r\n  - call to `free()` from callbacks executed within `call_rcu` worker\r\n    threads,\r\n  - executing `call_rcu` atfork handlers within the glibc pthread\r\n    atfork mechanism,\r\n\r\nwill sometimes trigger interesting process hangs. This usually\r\nhangs on a memory allocator lock within glibc.\r\n\r\n\r\n### Thread Local Storage (TLS)\r\n\r\nUserspace RCU can fall back on `pthread_getspecific()` to emulate\r\nTLS variables on systems where it is not available. This behavior\r\ncan be forced by specifying `--disable-compiler-tls` as configure\r\nargument.\r\n\r\n\r\n### Usage of `DEBUG_RCU`\r\n\r\n`DEBUG_RCU` is used to add internal debugging self-checks to the\r\nRCU library. This define adds a performance penalty when enabled.\r\nCan be enabled by uncommenting the corresponding line in\r\n`Makefile.build.inc`.\r\n\r\n\r\n### Usage of `DEBUG_YIELD`\r\n\r\n`DEBUG_YIELD` is used to add random delays in the code for testing\r\npurposes.\r\n\r\n\r\n### SMP support\r\n\r\nBy default the library is configured to use synchronization primitives\r\nadequate for SMP systems. On uniprocessor systems, support for SMP\r\nsystems can be disabled with:\r\n\r\n    ./configure --disable-smp-support\r\n\r\ntheoretically yielding slightly better performance.\r\n\r\n\r\nMake targets\r\n------------\r\n\r\nIn addition to the usual `make check` target, Userspace RCU features\r\n`make regtest` and `make bench` targets:\r\n\r\n  - `make check`: short tests, meant to be run when rebuilding or\r\n    porting Userspace RCU.\r\n  - `make regtest`: long (many hours) test, meant to be run when\r\n    modifying Userspace RCU or porting it to a new architecture or\r\n    operating system.\r\n  - `make bench`: long (many hours) benchmarks.\r\n\r\n\r\nContacts\r\n--------\r\n\r\nYou can contact the maintainers on the following mailing list:\r\n`lttng-dev@lists.lttng.org`.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}